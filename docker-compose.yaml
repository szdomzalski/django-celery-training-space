services:
  # Message Broker - RabbitMQ with Management UI or Redis
  broker:
    # image: "redis:alpine"
    # container_name: redis
    image: "rabbitmq:management"
    container_name: rabbitmq
    ports:
      - "5672:5672"   # RabbitMQ default port
      - "15672:15672" # RabbitMQ Management console

  # Flower - Celery monitoring tool
  flower:
    container_name: flower
    image: mher/flower
    ports:
      - "5555:5555"
    env_file: ".env"
    depends_on:
      - broker

  # Django application acting as a Celery task producer
  producer:
    container_name: django-producer
    build:
      context: ./demo_celery
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - ./demo_celery:/usr/src/app/
    ports:
      - "8001:8000"
    env_file: ".env"
    depends_on:
      - broker

  # Celery worker example integrated with Django codebase
  worker:
    container_name: celery-worker
    build:
      context: ./demo_celery
    # Command to start the Celery worker
    # -A specifies the Celery application instance
    # -n assigns a name to the worker
    # -l INFO sets the logging level to INFO
    # -Q specifies the queues to listen to (tasks and dead_letter)
    # -E stands for enabling events, which are required for monitoring tasks in Flower
    command: celery -A demo_celery worker -n my_django_based_celery_worker -l INFO -Q tasks,dead_letter -E
    volumes:
      - ./demo_celery:/usr/src/app/
    env_file: ".env"
    depends_on:
      - broker
      - producer

  # Celery worker example as a standalone service (without Django codebase)
  # celery_standalone:
  #   container_name: celery-standalone
  #   build:
  #     context: ./celery_standalone
  #   command: celery -A celery_standalone worker -l INFO -Q queue_multiply
  #   volumes:
  #     - ./celery_standalone:/usr/src/app/
  #   depends_on:
  #     - broker
  #     - producer